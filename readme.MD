<h1 align="center" font-size="200em"><b>SugestaoDePalavras/AutoCompletar</b></h1>

<div align = "center" >
<!-- imagem -->


[![requirement](https://img.shields.io/badge/IDE-Visual%20Studio%20Code-informational)](https://code.visualstudio.com/docs/?dv=linux64_deb)
![Make](https://img.shields.io/badge/Compilacao-Make-orange)
![Linguagem](https://img.shields.io/badge/Linguagem-C%2B%2B-blue)
</div>


## üìåSum√°rio

- [Introdu√ß√£o](#introdu√ß√£o)
- [Objetivos](#objetivos)
- [Arquivos](#arquivos)
- [Resolu√ß√£o do Problema](#resolu√ß√£o-do-problema)
- [Fun√ß√µes](#fun√ß√µes)
- [Resultados](#resultados)
- [Conclus√£o](#conclus√£o)
- [Refer√™ncias](#refer√™ncias)
- [Compila√ß√£o e execu√ß√£o](#compila√ß√£o-e-execu√ß√£o)
- [Contato](#contato)

## ‚úíÔ∏èIntrodu√ß√£o

Este √© um programa desenvolvido em C++ para a disciplina de Algoritmos e Estruturas de Dados II.

O presente trabalho aborda a identifica√ß√£o dos k elementos mais relevantes em um conjunto de dados. Estes elementos s√£o ent√£o empregados na cria√ß√£o de um sistema de autocompletar e sugest√£o de palavras para os usu√°rios. Para alcan√ßar esse objetivo, foram empregadas tr√™s estruturas fundamentais: √°rvore Bin√°ria Padr√£o, √°rvore AVL e √°rvore de Huffman. Essa abordagem permite a an√°lise comparativa do desempenho dessas estruturas durante o desenvolvimento do programa.

√â relevante mencionar que este c√≥digo incorpora a implementa√ß√£o da atividade anterior de Algoritmos e Estruturas de Dados I, que se concentra na identifica√ß√£o das palavras mais frequentes em um texto usando a estrutura de dados Heap m√≠nimo. Para obter informa√ß√µes mais detalhadas sobre essa parte espec√≠fica do c√≥digo, √© poss√≠vel acessar o seguinte link: Link para a implementa√ß√£o anterior. Isso proporciona aos interessados um contexto adicional sobre o projeto e sua evolu√ß√£o ao longo do curso.

## üíªObjetivos

O objetivo deste projeto √© criar um sistema de autocompletar e sugest√µes de palavras usando √°rvores bin√°rias como base. O sistema deve ser capaz de receber um arquivo de entrada contendo uma lista de palavras de pesquisa, construir √°rvores bin√°rias a partir de textos fornecidos, identificar palavras relevantes e apresentar os resultados em um arquivo de sa√≠da. Al√©m disso, o projeto inclui a explora√ß√£o de diferentes abordagens, incluindo a implementa√ß√£o de uma √°rvore Bin√°ria Padr√£o, a codifica√ß√£o de Huffman e a utiliza√ß√£o de √°rvores AVL, permitindo uma an√°lise comparativa do desempenho e funcionalidade das diferentes implementa√ß√µes das √°rvores bin√°rias no contexto do sistema de autocompletar e sugest√µes de palavras.

<strong><h4>Condi√ß√µes impostas: </h4></strong>
- Este programa dever√° ler uma cole√ß√£o de arquivos contento textos sem nenhuma formata√ß√£o ("arquivo ASCII") onde cada senten√ßa termina por um sinal de pontua√ß√£o (".", "?", "!").
- Cada par√°grafo √© separado por, pelo menos, uma linha em branco.
- Considere como palavra uma sequ√™ncia de letras delimitada por espa√ßo em branco, ‚Äùcoluna da esquerda‚Äù, ‚Äùcoluna da direita‚Äù e s√≠mbolos de pontua√ß√£o.
- O programa deve ser capaz de ler um ou mais arquivos de entrada com o nome "data/txt(x).txt," onde "x" pode ser ajustado pelo usu√°rio. Se houver 3 textos, por exemplo, os arquivos "txt1.txt," "txt2.txt," e "txt3.txt" devem ser adicionados √† pasta "data".
- O usu√°rio deve fornecer um arquivo chamado "input.data" na pasta "data," contendo uma lista de palavras-chave, uma por linha. Cada palavra ser√° tratada como um termo de pesquisa no sistema.
- Um arquivo de "stop words" tamb√©m √© fornecido na pasta "data" contendo artigos e conjun√ß√µes que devem ser ignorados ao contar as palavras mais frequentes. O usu√°rio pode personalizar essa lista conforme desejar.
- Ap√≥s o processamento, um arquivo chamado "output.txt" ser√° automaticamente gerado na pasta "data" para apresentar informa√ß√µes de sa√≠da de forma organizada. Esse arquivo incluir√° o nome do arquivo lido no formato "Texto x", a palavra pesquisada e sua frequ√™ncia. Al√©m disso, as tr√™s √°rvores bin√°rias ser√£o representadas usando o m√©todo central, juntamente com a √°rvore de Huffman codificada com base nos c√≥digos gerados, tamb√©m apresentados usando o m√©todo central.
- Faz parte do projeto do programa fornecer uma sa√≠da leg√≠vel.

## üìÑArquivos
<strong>main.cpp:</strong> Respons√°vel pela cria√ß√£o das principais estruturas do c√≥digo e chamadas das fun√ß√µes necess√°rias para o funcionamento do programa.

<strong>functions.hpp</strong> e <strong>functions.cpp:</strong> Encarregados da declara√ß√£o e desenvolvimento das fun√ß√µes gerais do c√≥digo.

<strong>tree.cpp</strong> e <strong>tree.hpp:</strong>> Encarregados da declara√ß√£o e desenvolvimento das fun√ß√µes da √°rvore bin√°ria padr√£o.

<strong>huffman.cpp</strong> e <strong>huffman.hpp:</strong> Respons√°veis pela declara√ß√£o e desenvolvimento das fun√ß√µes da √°rvore de codifica√ß√£o de Huffman.

<strong>avl.cpp</strong> e <strong>avl.hpp:</strong> Respons√°veis pela declara√ß√£o e desenvolvimento das fun√ß√µes da √°rvore AVL.

<strong>fila.cpp</strong> e <strong>fila.hpp:</strong> Respons√°veis pela declara√ß√£o e desenvolvimento das fun√ß√µes de uma fila, utilizadas para a impress√£o das √°rvores utilizando o m√©todo em n√≠veis, caso seja do interesse do usu√°rio.

<strong>data/txtx.txt:</strong> Arquivo de texto de entrada, onde "x" √© um par√¢metro ajust√°vel que representa o n√∫mero dos respectivos arquivos txt.

<strong>data/stopwords.txt:</strong> Arquivo de texto contendo as "stop words", como artigos (a, o, as, os) e conjun√ß√µes (e, ou).

<strong>data/input.data:</strong> Arquivo de dados contendo as palavras-chave de pesquisa, uma por linha.

## üî®Resolu√ß√£o do problema

A fim de resolver eficientemente o problema de identificar as K palavras mais frequentes em uma cole√ß√£o de textos, o c√≥digo utiliza uma combina√ß√£o eficaz de estruturas de dados: o uso de um Unordered Map como Tabela Hash e a utiliza√ß√£o de um Heap M√≠nimo para manter as K palavras mais frequentes.

Para entender melhor como essas estruturas de dados se relacionam com o problema em quest√£o no contexto do c√≥digo, voc√™ pode consultar a documenta√ß√£o do reposit√≥rio mencionado na introdu√ß√£o.

No desenvolvimento deste c√≥digo para resolver o novo problema, foram empregadas as seguintes estruturas de dados:

<h3><b>√Årvore Bin√°ria Padr√£o</b></h3>

Uma √°rvore bin√°ria padr√£o representa uma estrutura de dados n√£o linear organizada hierarquicamente. Em uma √°rvore bin√°ria, cada n√≥ pode ter, no m√°ximo, dois filhos: um √† esquerda e outro √† direita. Cada n√≥ armazena um elemento de dados e possui refer√™ncias para seus filhos, um √† esquerda e outro √† direita. O n√≥ de topo na hierarquia √© conhecido como o n√≥ raiz da √°rvore.

Dentro de uma √°rvore de busca bin√°ria, segue-se a regra de que o valor de um n√≥ √† esquerda √© menor que o valor do n√≥ pai, enquanto o valor de um n√≥ √† direita √© maior que o valor do n√≥ pai. Essa regra √© aplicada recursivamente √†s sub√°rvores √† esquerda e √† direita da raiz.

<p align="center">
  <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/2f215d21-5342-479f-b574-739b0be86b1b" width="500px" height="auto" alt="gif">
</p>

<p align="center">
  GIF criado utilizando o simulador dispon√≠vel em: https://www.cs.usfca.edu/~galles/visualization/BST.html
</p>


<br>No GIF acima, podemos observar que o n√≥ raiz √© 15, e todos os n√≥s da sub√°rvore esquerda s√£o menores que o n√≥ raiz, e todos os n√≥s da sub√°rvore direita s√£o maiores que o n√≥ raiz. √â poss√≠vel observar tamb√©m que o lado esquerdo da √°rvore obteve uma altura 5, enquanto o lado direito obteve uma altura 2, o que mostra que a √°rvore est√° desequilibrada.

No c√≥digo desenvolvido, quando o valor de um n√≥ √© igual ao valor da raiz, esses n√≥s s√£o direcionados para a esquerda.

A complexidade de tempo para opera√ß√µes em uma √°rvore bin√°ria depende da altura da √°rvore. No pior caso, em uma √°rvore desbalanceada, as opera√ß√µes podem ter uma complexidade de O(n), onde "n" √© o n√∫mero de elementos na √°rvore. No entanto, em uma √°rvore balanceada, como uma √°rvore de busca bin√°ria balanceada, as opera√ß√µes de busca, inser√ß√£o e remo√ß√£o t√™m uma complexidade m√©dia de O(log n), onde "n" √© o n√∫mero de elementos.

<h3><b>√Årvore de Huffman</b></h3>

Uma √°rvore de Huffman representa uma estrutura de dados usada principalmente para compress√£o de dados, como em algoritmos de compacta√ß√£o de arquivos. Ela √© constru√≠da a partir de um conjunto de s√≠mbolos, onde cada s√≠mbolo tem uma frequ√™ncia associada. A ideia central √© atribuir c√≥digos bin√°rios menores √†s frequ√™ncias mais altas, otimizando assim a compress√£o.

A codifica√ß√£o e decodifica√ß√£o da √°rvore de Huffman envolvem a representa√ß√£o dos s√≠mbolos em um c√≥digo bin√°rio. Os s√≠mbolos s√£o dispostos nas folhas da √°rvore, e os caminhos da raiz √†s folhas representam os c√≥digos bin√°rios associados a esses s√≠mbolos. A codifica√ß√£o de Huffman √© gerada atribuindo "1" quando se move para a direita na √°rvore e "0" quando se move para a esquerda.

Dentro de uma √°rvore de Huffman, os s√≠mbolos com maiores frequ√™ncias s√£o geralmente posicionados mais pr√≥ximos da raiz, enquanto os s√≠mbolos com menores frequ√™ncias est√£o nas folhas mais distantes. Isso garante que os s√≠mbolos mais frequentes tenham c√≥digos mais curtos, o que otimiza a compacta√ß√£o.

Nesse c√≥digo, o processo de codifica√ß√£o de Huffman se inicia com a constru√ß√£o de uma √°rvore que se baseia nas frequ√™ncias das palavras. Posteriormente, essa √°rvore √© empregada para gerar c√≥digos individuais para cada palavra. 

O GIF abaixo ilustra o processo de constru√ß√£o de uma √°rvore de codifica√ß√£o de Huffman para as palavras: "entre", "modo", "mundo", "sujeito" e "teoria", junto com suas respectivas frequ√™ncias no arquivo "txt1.txt" dispon√≠vel na pasta "data" (frequ√™ncias: 127, 129, 134, 145 e 176).

<div align="center">
  <figure>
    <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/bc91d3ed-250e-452e-b637-3b719e03f9cb" width="500px" height="auto" alt=".">
    <figcaption>Constru√ß√£o de uma √°rvore de codifica√ß√£o Huffman</figcaption>
  </figure>
</div>

<br> √â evidente que a constru√ß√£o da √°rvore segue uma l√≥gica de ordenar as palavras de acordo com suas frequ√™ncias, neste caso, em ordem crescente, e ent√£o combinar sempre as duas frequ√™ncias mais baixas em um √∫nico n√≥, e reorganizar as palavras novamente. Esse processo √© repetido at√© que reste apenas um √∫nico n√≥ na √°rvore. Posteriormente, para atribuir c√≥digos a cada palavra, percorremos a √°rvore, adicionando "1" quando seguimos para a direita e "0" quando seguimos para a esquerda. Isso resulta em c√≥digos √∫nicos para cada palavra na √°rvore de Huffman.

A complexidade de tempo para a constru√ß√£o da √°rvore de Huffman √© geralmente O(n log n), onde "n" √© o n√∫mero de s√≠mbolos. No entanto, uma vez que a √°rvore est√° constru√≠da, a codifica√ß√£o e a decodifica√ß√£o t√™m complexidade O(log n), o que a torna eficiente para a compress√£o de dados.

<h3><b>√Årvore AVL</b></h3>

Uma √°rvore AVL √© uma estrutura de dados de √°rvore bin√°ria de busca balanceada, e sua principal caracter√≠stica √© a manuten√ß√£o autom√°tica do equil√≠brio ap√≥s inser√ß√µes e remo√ß√µes de elementos. Essa manuten√ß√£o √© realizada por meio de rota√ß√µes, que reorganizam a √°rvore para garantir que a diferen√ßa de altura entre as sub√°rvores esquerda e direita de cada n√≥ (fator de balanceamento) seja, no m√°ximo, 1.

As rota√ß√µes desempenham um papel fundamental no processo de balanceamento das √°rvores AVL e podem ser divididas em quatro configura√ß√µes distintas:

‚ñ∂ Rota√ß√£o Simples √† Esquerda:<br>
Essa rota√ß√£o √© aplicada quando um n√≥ desequilibrado tem uma sub√°rvore direita mais alta do que a sub√°rvore esquerda, violando a condi√ß√£o de equil√≠brio.
A rota√ß√£o simples √† esquerda envolve uma √∫nica opera√ß√£o que move o filho direito do n√≥ desequilibrado para a posi√ß√£o do n√≥ pai, enquanto o n√≥ pai se torna o filho esquerdo do n√≥ anteriormente filho direito.

‚ñ∂ Rota√ß√£o Simples √† Direita:<br>
Essa rota√ß√£o √© aplicada quando um n√≥ desequilibrado tem uma sub√°rvore esquerda mais alta do que a sub√°rvore direita, violando a condi√ß√£o de equil√≠brio.
A rota√ß√£o simples √† direita √© semelhante √† rota√ß√£o √† esquerda, mas envolve movimentos na dire√ß√£o oposta, onde o filho esquerdo do n√≥ desequilibrado se torna o novo n√≥ pai, e o n√≥ pai se torna o filho direito do n√≥ anteriormente filho esquerdo.

‚ñ∂ Rota√ß√£o Dupla √† Esquerda:<br>
Esta rota√ß√£o √© necess√°ria quando ocorre uma desigualdade de altura na sub√°rvore direita de um n√≥ e a sub√°rvore esquerda de seu filho direito.
A rota√ß√£o dupla √† esquerda envolve duas rota√ß√µes simples: primeiro uma rota√ß√£o simples √† direita no filho direito do n√≥ desequilibrado, seguida por uma rota√ß√£o simples √† esquerda no n√≥ desequilibrado.

‚ñ∂ Rota√ß√£o Dupla √† Direita:<br>
Esta rota√ß√£o √© aplicada quando h√° uma desigualdade de altura na sub√°rvore esquerda de um n√≥ e a sub√°rvore direita de seu filho esquerdo.
A rota√ß√£o dupla √† direita consiste em duas rota√ß√µes simples consecutivas: primeiro, uma rota√ß√£o simples √† esquerda no filho esquerdo do n√≥ desequilibrado, seguida por uma rota√ß√£o simples √† direita no n√≥ desequilibrado.

O processo de balanceamento de uma √°rvore bin√°ria tem como objetivo a redu√ß√£o do n√∫mero m√©dio de compara√ß√µes necess√°rias para encontrar qualquer elemento na √°rvore. Durante as opera√ß√µes de inser√ß√£o e remo√ß√£o, h√° uma tend√™ncia de desequil√≠brio na √°rvore, o que implica em um custo adicional nessas etapas para garantir que o equil√≠brio seja sempre mantido. 

No entanto, √© importante notar que esses mecanismos de balanceamento, garantem que a altura da √°rvore seja mantida em um limite logar√≠tmico em rela√ß√£o ao n√∫mero de elementos "n". No GIF abaixo, √© poss√≠vel perceber que os elementos s√£o os mesmos inseridos na √°vore Bin√°ria Padr√£o anteriormente, e enquanto na AVL a diferen√ßa de altura do lado esquerdo para o lado direito foi apenas 1, na AVL foi 3.

<div align="center">
  <figure>
    <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/df3263b3-ff35-404f-a5d7-49cdf7b727d0" width="500px" height="auto" alt=".">
    <figcaption>GIF criado utilizando o simulador dispon√≠vel em: https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</figcaption>
  </figure>
</div>

<br> Portanto, independentemente da sequ√™ncia de opera√ß√µes realizadas, a √°rvore AVL continua a fornecer um desempenho eficiente e previs√≠vel para opera√ß√µes de busca, inser√ß√£o e remo√ß√£o, com a complexidade limitada a O(log n). 

## üî® Fun√ß√µes 

As fun√ß√µes utilizadas para encontrar as K palavras mais recorrentes do texto foram detalhadamente especificadas na documenta√ß√£o do Trabalho de AED I. Por√©m, houve altera√ß√µes em rela√ß√£o √† elimina√ß√£o de caracteres especiais durante a leitura, substituindo o uso de regex por um m√©todo idiom√°tico, que √© eficaz para remover caracteres indesejados e realizar opera√ß√µes de limpeza em strings. Al√©m disso, vale destacar que s√£o encontradas k+1 palavras mais recorrentes. Isso permite que, caso uma das palavras seja igual √† palavra de busca atual, ela seja substitu√≠da por outra que seja ainda mais recorrente.

- ```copiarVetor(vector<pair<string, int>> vetor, vector<pair<string, int>>& copia, queue<string> palavras, int k):``` Essa fun√ß√£o percorre o vetor "heap", que cont√©m as k+1 palavras mais recorrentes do texto. Em cada itera√ß√£o, ela adiciona cada palavra a um vetor auxiliar e chama a fun√ß√£o "heapify" para reorganizar esse vetor como um heap m√≠nimo. No entanto, caso a palavra atual de busca seja encontrada durante a itera√ß√£o, ela n√£o √© inclu√≠da no vetor auxiliar. No final da execu√ß√£o, o vetor auxiliar ser√° id√™ntico ao heap, contendo k palavras, e n√£o incluir√° a palavra atual de busca. Isso garante que o vetor resultante contenha as k palavras mais recorrentes, excluindo a palavra de busca atual.

‚ñ∂ √Årvore Bin√°ria Padr√£o:

- ```CreateBasicTree:``` Essa fun√ß√£o cria e retorna uma √°rvore bin√°ria vazia baseada na estrutura `TreeBasic`. Inicialmente, a √°rvore √© criada com um n√≥ raiz representado pelo ponteiro `nullptr`, indicando que n√£o h√° elementos na √°rvore no momento da cria√ß√£o.

    A estrutura `TreeBasic` √© composta por tr√™s elementos principais:
        1. `reg`: Este campo armazena um registro do tipo `RecordBasic`, que consiste em uma string de chave (`chave`) e um valor inteiro (`valor`). Neste contexto, cada n√≥ da √°rvore bin√°ria cont√©m um par de valores chave-valor associados.
        2. `esq`: Este √© um ponteiro para o filho esquerdo do n√≥ na √°rvore. Inicialmente, quando a √°rvore √© criada com `CreateBasicTree`, esse ponteiro est√° definido como `nullptr`, indicando que n√£o h√° filho esquerdo.
        3. `dir`: Similarmente, este √© um ponteiro para o filho direito do n√≥ na √°rvore, e tamb√©m √© inicializado como `nullptr`.

    Resumindo, a fun√ß√£o `CreateBasicTree` √© respons√°vel por configurar uma √°rvore bin√°ria b√°sica vazia que pode ser usada posteriormente para adicionar elementos e construir uma estrutura hier√°rquica de dados. Por padr√£o, quando esta fun√ß√£o √© chamada, ela retorna um ponteiro nulo (`nullptr`), indicando que a √°rvore est√° vazia e pronta para a inser√ß√£o de dados.

- ```TVaziaBasicTree(TreeBasic t):``` Essa fun√ß√£o verifica se uma √°rvore bin√°ria de busca (representada pelo ponteiro t) est√° vazia. Ela retorna true se a √°rvore estiver vazia (ponteiro nulo) e false caso contr√°rio.

- ```deleteBasicTree(TreeBasic &t):``` Essa fun√ß√£o √© respons√°vel por liberar a mem√≥ria associada a uma √°rvore bin√°ria de busca e garantir que todos os seus n√≥s sejam devidamente desalocados. O ponteiro t passado por refer√™ncia √© atualizado para nulo ap√≥s a libera√ß√£o.

- ```insertBasicTree(TreeBasic t, RecordBasic r):``` Essa fun√ß√£o insere um novo registro r em uma √°rvore bin√°ria de busca representada por t. Ela verifica se a √°rvore est√° vazia e insere o novo n√≥ na posi√ß√£o adequada para manter a propriedade de √°rvore de busca bin√°ria, levando em considera√ß√£o o valor do registro r.

<div align="center">
  <figure>
    <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/22b60d92-78a4-46ee-97af-77b24b0d33d5" width="500px" height="auto" alt=".">
    <figcaption>Fun√ß√£o insertBasicTree</figcaption>
  </figure>
</div>

<br>

- ```preordemBasicTree(TreeBasic t, ofstream &file):``` Essa fun√ß√£o realiza uma travessia pr√©-ordem na √°rvore bin√°ria de busca t e escreve os registros no arquivo de sa√≠da file. A travessia pr√©-ordem visita primeiro o n√≥ raiz, seguido dos n√≥s √† esquerda e, por fim, dos n√≥s √† direita.

- ```centralBasicTree(TreeBasic t, ofstream &file):``` Essa fun√ß√£o realiza uma travessia em ordem (ou central) na √°rvore bin√°ria de busca t e escreve os registros no arquivo de sa√≠da file. A travessia em ordem visita primeiro os n√≥s √† esquerda, seguido do n√≥ raiz e, por fim, dos n√≥s √† direita.

- ```posordemBasicTree(TreeBasic t, ofstream &file):``` Essa fun√ß√£o realiza uma travessia p√≥s-ordem na √°rvore bin√°ria de busca t e escreve os registros no arquivo de sa√≠da file. A travessia p√≥s-ordem visita primeiro os n√≥s √† esquerda, seguido dos n√≥s √† direita e, por fim, o n√≥ raiz.

- ```escreveroutputBasicTree(std::ofstream &file, TreeBasic t):``` Essa fun√ß√£o escreve no arquivo de sa√≠da file uma representa√ß√£o dos registros armazenados na √°rvore bin√°ria de busca t. Ela inclui registros na ordem definida pela fun√ß√£o centralBst e adiciona um cabe√ßalho indicando que se trata de uma √°rvore bin√°ria.

‚ñ∂ √Årvore de Huffman:

- ```CreateRaizTreeHuffman:``` Esta fun√ß√£o cria e retorna uma √°rvore de Huffman vazia com um n√≥ raiz representado pelo ponteiro `nullptr`. A estrutura `TreeHuffman` √© composta pelos seguintes elementos:
   1. `reg`: Este campo armazena um registro do tipo `RecordHuffman`, que inclui uma string de chave (`chave`) e um valor de frequ√™ncia (`freq`).
   2. `esq` e `dir`: Esses s√£o ponteiros para os filhos esquerdo e direito da √°rvore de Huffman, inicialmente definidos como `nullptr`.
   3. `huffmanCode`: Este campo √© usado para armazenar o c√≥digo de Huffman associado a um n√≥.

- ```TVaziaHuffman(TreeHuffman* t):``` Esta fun√ß√£o verifica se uma √°rvore de Huffman (representada pelo ponteiro `t`) est√° vazia. Ela retorna `true` se a √°rvore estiver vazia (ponteiro nulo) e `false` caso contr√°rio.

- ```deleteTreeHuffman(TreeHuffman* &t):``` Esta fun√ß√£o √© respons√°vel por liberar a mem√≥ria associada a uma √°rvore de Huffman e garantir que todos os seus n√≥s sejam devidamente desalocados. O ponteiro `t` passado por refer√™ncia √© atualizado para nulo ap√≥s a libera√ß√£o.

- ```createHuffmanTreeHelper(TreeHuffman* t, string code):``` Esta fun√ß√£o auxiliar √© usada para calcular os c√≥digos de Huffman associados aos n√≥s da √°rvore de Huffman. Ela percorre a √°rvore e armazena os c√≥digos nos n√≥s folha, atribuindo "1" quando se move para a direita na √°rvore e "0" quando se move para a esquerda.

- ```createHuffmanTree(vector<pair<string, int>> tabFreq):``` Esta fun√ß√£o cria uma √°rvore de Huffman com base em uma tabela de frequ√™ncia de palavras. Ela constr√≥i a √°rvore mesclando os n√≥s de acordo com suas frequ√™ncias, usando uma fila de prioridade. Em seguida, chama a fun√ß√£o auxiliar `createHuffmanTreeHelper` para calcular os c√≥digos de Huffman.

<div align="center">
  <figure>
    <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/d1ec4ab7-eea4-4656-b317-c11655cfb486" width="500px" height="auto" alt=".">
    <figcaption>Fun√ß√£o createHuffmanTree</figcaption>
  </figure>
</div>

<br>

- ```printHuffmanTree(TreeHuffman* t):``` Esta fun√ß√£o imprime os n√≥s da √°rvore de Huffman juntamente com seus c√≥digos de Huffman e frequ√™ncias. √â usada para depura√ß√£o e visualiza√ß√£o da √°rvore.

- ```preordemHuffman(TreeHuffman* t, ofstream &file):``` Esta fun√ß√£o realiza uma travessia pr√©-ordem na √°rvore de Huffman `t` e escreve os registros em um arquivo de sa√≠da `file`. A travessia pr√©-ordem visita primeiro o n√≥ raiz, seguido dos n√≥s √† esquerda e, por fim, dos n√≥s √† direita.

- ```centralHuffman(TreeHuffman* t, ofstream &file):``` Esta fun√ß√£o realiza uma travessia em ordem (ou central) na √°rvore de Huffman `t` e escreve os registros em um arquivo de sa√≠da `file`. A travessia em ordem visita primeiro os n√≥s √† esquerda, seguido do n√≥ raiz e, por fim, dos n√≥s √† direita.

- ```posordemHuffman(TreeHuffman* t, ofstream &file):``` Esta fun√ß√£o realiza uma travessia p√≥s-ordem na √°rvore de Huffman `t` e escreve os registros em um arquivo de sa√≠da `file`. A travessia p√≥s-ordem visita primeiro os n√≥s √† esquerda, seguido dos n√≥s √† direita e, por fim, o n√≥ raiz.

- ```escreveroutputHuffman(ofstream &file, TreeHuffman* t):``` Esta fun√ß√£o escreve no arquivo de sa√≠da `file` uma representa√ß√£o dos registros armazenados na √°rvore de Huffman `t`. Ela inclui registros na ordem definida pela fun√ß√£o `centralHuffman` e adiciona um cabe√ßalho indicando que se trata de uma √°rvore de Huffman.

‚ñ∂ √Årvore AVL:

- ```CreateTreeAvl:``` Essa fun√ß√£o cria e retorna uma √°rvore AVL (√Årvore de Busca Bin√°ria Balanceada) vazia baseada na estrutura `TreeAvl`. Inicialmente, a √°rvore √© criada com um n√≥ raiz representado pelo ponteiro `nullptr`, indicando que n√£o h√° elementos na √°rvore no momento da cria√ß√£o.

    A estrutura `TreeAvl` √© composta por quatro elementos principais:
        1. `reg`: Este campo armazena um registro do tipo `RecordAvl`, que consiste em uma string de chave (`chave`) e um valor inteiro (`valor`). Cada n√≥ da √°rvore bin√°ria cont√©m um par de valores chave-valor associados.
        2. `esq`: Este √© um ponteiro para o filho esquerdo do n√≥ na √°rvore. Inicialmente, quando a √°rvore √© criada com `CreateTreeAvl`, esse ponteiro √© definido como `nullptr`, indicando que n√£o h√° filho esquerdo.
        3. `dir`: Similarmente, este √© um ponteiro para o filho direito do n√≥ na √°rvore e tamb√©m √© inicializado como `nullptr`.
        4. `weight`: Este campo mant√©m o fator de balanceamento (peso) do n√≥, que √© usado para garantir que a √°rvore AVL permane√ßa balanceada.

- ```deleteTreeAVL(TreeAvl*& t):``` Essa fun√ß√£o √© respons√°vel por liberar a mem√≥ria associada a uma √°rvore AVL e garantir que todos os seus n√≥s sejam devidamente desalocados. O ponteiro `t` passado por refer√™ncia √© atualizado para nulo ap√≥s a libera√ß√£o.

- ```insertTreeAvl(TreeAvl** t, RecordAvl r):``` Essa fun√ß√£o insere um novo registro `r` em uma √°rvore AVL representada por `t`. Ela verifica se a √°rvore est√° vazia e insere o novo n√≥ na posi√ß√£o adequada para manter a propriedade de √°rvore de busca bin√°ria balanceada, levando em considera√ß√£o o valor do registro `r`. Al√©m disso, ela realiza rota√ß√µes simples ou duplas, se necess√°rio, para manter o balanceamento da √°rvore.

<div align="center">
  <figure>
    <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/504e828e-5384-4d82-aa92-9be9ae9f01ec" width="500px" height="auto" alt=".">
    <figcaption>Fun√ß√£o insertTreeAvl</figcaption>
  </figure>
</div>
<br>

- ```pesquisaAvl(TreeAvl** t, TreeAvl** aux, RecordAvl r):``` Essa fun√ß√£o busca um registro na √°rvore AVL. Se o registro for encontrado, o ponteiro `aux` aponta para o n√≥ correspondente; caso contr√°rio, uma mensagem de erro √© exibida.

- ```removeTreeAvl(TreeAvl** t, TreeAvl** f, RecordAvl r):``` Essa fun√ß√£o remove um registro da √°rvore AVL. Ela verifica se o registro existe na √°rvore, remove-o e realiza rebalanceamento, se necess√°rio, para manter a √°rvore balanceada.

- ```preordemAvl(TreeAvl* t, ofstream &file):``` Essa fun√ß√£o realiza uma travessia pr√©-ordem na √°rvore AVL `t` e escreve os registros em um arquivo de sa√≠da `file`. A travessia pr√©-ordem visita primeiro o n√≥ raiz, seguido dos n√≥s √† esquerda e, por fim, dos n√≥s √† direita.

- ```centralAvl(TreeAvl* t, ofstream &file):``` Essa fun√ß√£o realiza uma travessia em ordem (ou central) na √°rvore AVL `t` e escreve os registros em um arquivo de sa√≠da `file`. A travessia em ordem visita primeiro os n√≥s √† esquerda, seguido do n√≥ raiz e, por fim, dos n√≥s √† direita.

- ```posordemAvl(TreeAvl* t, ofstream &file):``` Essa fun√ß√£o realiza uma travessia p√≥s-ordem na √°rvore AVL `t` e escreve os registros em um arquivo de sa√≠da `file`. A travessia p√≥s-ordem visita primeiro os n√≥s √† esquerda, seguido dos n√≥s √† direita e, por fim, o n√≥ raiz.

- ```escreveroutputAvl(std::ofstream &file, TreeAvl* t):``` Essa fun√ß√£o escreve no arquivo de sa√≠da `file` uma representa√ß√£o dos registros armazenados na √°rvore AVL `t`. Ela inclui registros na ordem definida pela fun√ß√£o `centralAvl` e adiciona um cabe√ßalho indicando que se trata de uma √°rvore AVL.

‚ñ∂ main.cpp:

- Na fun√ß√£o principal (main), al√©m de invocar as fun√ß√µes respons√°veis pelo funcionamento do c√≥digo, s√£o realizadas opera√ß√µes de abertura de arquivos de texto a serem lidos e a coleta das palavras-chave de busca. Para cada texto lido, √© criado um gloss√°rio espec√≠fico, juntamente com um vetor que representa uma estrutura de heap m√≠nimo e outro vetor que armazena todas as palavras-chave.

    O processo se inicia com a leitura da primeira palavra do vetor. Se a palavra existir no gloss√°rio, ou seja, no texto em an√°lise, o c√≥digo gera uma c√≥pia do vetor da heap, removendo a palavra em quest√£o, desde que esta esteja entre as mais frequentes. Em seguida, s√£o criadas as tr√™s √°rvores e as palavras da c√≥pia da heap s√£o inseridas em cada uma delas. Os resultados s√£o registrados no arquivo de sa√≠da (output) e, em seguida, as √°rvores s√£o eliminadas. No caso em que a palavra n√£o existe no texto, o c√≥digo apenas a registra no arquivo de sa√≠da com a mensagem indicando que a palavra n√£o foi encontrada no texto em quest√£o.

    Ap√≥s a conclus√£o desse processo para a primeira palavra do vetor, essa palavra √© removida e a pr√≥xima palavra √© lida, repetindo-se o ciclo. Esse processo continua at√© que o vetor de palavras-chave esteja vazio. Posteriormente, o gloss√°rio √© deletado, e o pr√≥ximo texto √© lido e todo o processo se repete novamente. Esse ciclo √© repetido at√© que todos os textos tenham sido lidos, e todas as √°rvores tenham sido criadas e seus resultados inseridos no arquivo de sa√≠da.


## üéØResultados

‚ñ∂ Arquivo output:

<h4><b>Entradas: </b></h4>
<div align="center">
  <figure>
    <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/6cb45f0b-bc5d-42c6-a741-224377e5fe62" width="700px" height="auto" alt=".">
    <figcaption>Entradas: txt1.txt e txt2.txt, dispon√≠veis na pasta "data" (qtdArq=2), com 7 palavras mais recorrentes (k=7) e 2 palavras-chave de busca</figcaption>
  </figure>
</div>

<h4><b>Saida:</b></h4>
<div align="center">
  <figure>
    <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/3dccdf7a-55af-4dce-af6b-a7c03d82d0fb" width="800px" height="auto" alt=".">
    <figcaption>Arquivo "output.data" ap√≥s a execu√ß√£o</figcaption>
  </figure>
</div>


‚ñ∂ Terminal de comando:

<h4><b>Entradas:</b></h4>

Todos os 6 arquivos de texto dispon√≠veis na pasta "data" (qtdArq=6), com 10 palavras mais recorrentes (k=10) e 1 palavra-chave de busca. </b></h4>


<h4><b>Saida:</b></h4>
<div align="center">
  <figure>
    <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/23c60e4d-f9c8-409c-afd4-4ae4dde05e3c" width="450px" height="auto" alt=".">
    <figcaption>Sa√≠da do terminal de comando</figcaption>
  </figure>
</div>



## ‚úîÔ∏èConclus√£o

Neste projeto, foi implementado tr√™s estruturas de √°rvores bin√°rias (√Årvore Bin√°ria Padr√£o, √Årvore de Huffman e √Årvore AVL) para processar e analisar textos. Com base nos resultados obtidos, podemos fazer algumas considera√ß√µes importantes sobre o desempenho e a utilidade de cada uma dessas estruturas.

A √Årvore Bin√°ria Padr√£o apresentou um tempo de execu√ß√£o consistente e relativamente baixo em compara√ß√£o com as outras estruturas. Sua simplicidade a torna uma op√ß√£o vi√°vel, especialmente quando se prioriza a simplicidade no c√≥digo. No entanto, uma desvantagem significativa dessa abordagem reside na aus√™ncia de balanceamento autom√°tico da √°rvore. Isso pode resultar em um caminhamento ineficiente, particularmente quando um lado da √°rvore se torna substancialmente maior que o outro. Esse desequil√≠brio pode impactar negativamente o desempenho da busca, aumentando o n√∫mero de passos necess√°rios para encontrar palavras-chave, o que pode ser problem√°tico em cen√°rios de alta demanda de processamento.

A √Årvore de Huffman mostrou um tempo de execu√ß√£o mais longo em compara√ß√£o com a √Årvore Bin√°ria Padr√£o e a √Årvore AVL. Essa estrutura √© especialmente √∫til quando o foco principal √© a compacta√ß√£o de dados, como na compress√£o de arquivos. No contexto deste projeto, a √Årvore de Huffman fornece uma representa√ß√£o eficiente das palavras com base na frequ√™ncia. No entanto, essa efici√™ncia vem com um custo em termos de tempo de execu√ß√£o.

A √Årvore AVL apresentou um desempenho s√≥lido, mesmo em grandes conjuntos de dados. Ela manteve tempos de execu√ß√£o razo√°veis, o que a torna uma escolha s√≥lida para sistemas de autocompletar e sugest√µes de palavras. A principal vantagem da √Årvore AVL √© a capacidade de manter um equil√≠brio entre a estrutura da √°rvore, o que garante tempos de busca previs√≠veis.

A escolha da estrutura de √°rvore depende das necessidades espec√≠ficas do projeto. Se a prioridade for a efici√™ncia na pesquisa em tempo real, a √Årvore Bin√°ria Padr√£o pode ser uma boa escolha devido ao seu tempo de execu√ß√£o mais r√°pido.  No entanto, se o projeto envolver frequentes opera√ß√µes de busca e inser√ß√£o, a √Årvore AVL √© a op√ß√£o mais equilibrada, garantindo um bom desempenho em ambas as opera√ß√µes. Por outro lado, a √Årvore de Huffman √© mais apropriada para cen√°rios que envolvem a compress√£o de dados, onde a economia de espa√ßo √© fundamental, tornando-a a escolha ideal para essas situa√ß√µes espec√≠ficas.

Em resumo, este projeto demonstrou a import√¢ncia da escolha da estrutura de dados adequada para atender √†s demandas espec√≠ficas de um sistema. Cada estrutura tem suas vantagens e desvantagens, e a decis√£o deve ser baseada nas necessidades de desempenho e relev√¢ncia do projeto em quest√£o.

## ‚úîÔ∏èRefer√™ncias
- https://www.cs.usfca.edu/~galles/visualization/BST.html
- https://www.programiz.com/dsa/binary-search-tree
- https://www.youtube.com/watch?v=o8UPZ_KDWdU
- https://www.youtube.com/watch?v=wrOrg1GdS-0
- https://www.programiz.com/dsa/huffman-coding
- https://www.cs.usfca.edu/~galles/visualization/AVLtree.html
- https://www.programiz.com/dsa/avl-tree
- https://www.youtube.com/watch?v=l8IBdCb2BWA&t=0s

## üëæCompila√ß√£o e execu√ß√£o

* Especifica√ß√µes da m√°quina em que o c√≥digo foi rodado:
  * AMD Ryzen 5-3500U;
  * Sistema Operacional Windows 11 Pro e Sistema Operacional Linux;
  * Terminal do Visual Studio;
  * 12GB de RAM.

* **(üö®)** Inicialmente, cinco configura√ß√µes precisam ser especificadas no c√≥digo:

  * **Quantidade de Arquivos a Serem Lidos:**
  Para permitir a leitura de um ou v√°rios arquivos de texto, voc√™ deve definir a quantidade na vari√°vel qtdArq. Al√©m disso, nomeie todos os arquivos como data/input(x).txt, em que o valor de x √© um par√¢metro ajust√°vel. Por exemplo, se deseja processar dois arquivos de entrada, os nomes ser√£o data/input1.txt e data/input2.txt, seguindo essa sequ√™ncia para a quantidade de arquivos definida em qtdArq. √â importante observar que a pasta chamada "data" foi criada para alocar os arquivos de entrada.

  * **Quantidade de Palavras com Maior Ocorr√™ncia Desejada:**
  Para obter as K palavras mais frequentes no texto, voc√™ s√≥ precisa ajustar a vari√°vel "k" para o valor desejado. Por exemplo, se almeja as 20 palavras mais recorrentes, basta definir k=20. Isso permitir√° que o c√≥digo identifique e exiba as palavras mais frequentes conforme a quantidade definida.

      <br> <img src="https://github.com/MariRodriguess/TOP_K_Elementos/assets/127866299/477dabdd-de12-4ef2-bbea-1c95a50ec8fe">

  * **Palavras-chaves de busca:**
  Para utilizar as palavras desejadas como crit√©rios de busca, basta inclu√≠-las no arquivo "input.data" seguindo o formato ilustrado abaixo:
 
      <br> <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/3ea5e983-618a-49e4-b95b-e0201a82067d">

  * **Palavras stopwords:**
  Para adicionar palavras espec√≠ficas como palavras de parada (stopwords), basta list√°-las no arquivo "stopword.txt" conforme o formato exemplificado a seguir:
   
      <br> <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/4b193044-2256-41ea-b627-4b54b7af9893">

  * **Textos a serem lidos:**
  Para adicionar os textos que ser√£o processados, basta coloc√°-los na pasta "data" e nome√°-los no padr√£o "txt(x).txt", como ilustrado abaixo:

      <br> <img src="https://github.com/MariRodriguess/SugestaoDePalavras-AutoCompletar/assets/127866299/69089a9b-4954-4bbf-9fd1-26807b7970d3">


* | Comando                |  Fun√ß√£o                                                                                           |                     
  | -----------------------| ------------------------------------------------------------------------------------------------- |
  |  `make clean`          | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                                        |
  |  `make`                | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build           |
  |  `make run`            | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                                 |

## ‚úâÔ∏èContato
<div>
 <br><p align="justify"> Mariana Rodrigues Lamounier Melo</p>
 <a href="https://t.me/MariRodriguess0">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:mariana.itapec@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>mariana.itapec@gmail.com</i>
</a>
